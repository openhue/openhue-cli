// Package openhue provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package openhue

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	HueApplicationKeyScopes = "HueApplicationKey.Scopes"
)

// Defines values for BridgeGetType.
const (
	BridgeGetTypeBridge BridgeGetType = "bridge"
)

// Defines values for BridgeHomeGetType.
const (
	BridgeHomeGetTypeBridgeHome BridgeHomeGetType = "bridge_home"
)

// Defines values for BridgePutType.
const (
	BridgePutTypeBridge BridgePutType = "bridge"
)

// Defines values for LightArchetype.
const (
	Bollard           LightArchetype = "bollard"
	CandleBulb        LightArchetype = "candle_bulb"
	CeilingHorizontal LightArchetype = "ceiling_horizontal"
	CeilingRound      LightArchetype = "ceiling_round"
	CeilingSquare     LightArchetype = "ceiling_square"
	CeilingTube       LightArchetype = "ceiling_tube"
	ChristmasTree     LightArchetype = "christmas_tree"
	ClassicBulb       LightArchetype = "classic_bulb"
	DoubleSpot        LightArchetype = "double_spot"
	EdisonBulb        LightArchetype = "edison_bulb"
	EllipseBulb       LightArchetype = "ellipse_bulb"
	FlexibleLamp      LightArchetype = "flexible_lamp"
	FloodBulb         LightArchetype = "flood_bulb"
	FloorLantern      LightArchetype = "floor_lantern"
	FloorShade        LightArchetype = "floor_shade"
	GroundSpot        LightArchetype = "ground_spot"
	HueBloom          LightArchetype = "hue_bloom"
	HueCentris        LightArchetype = "hue_centris"
	HueGo             LightArchetype = "hue_go"
	HueIris           LightArchetype = "hue_iris"
	HueLightstrip     LightArchetype = "hue_lightstrip"
	HueLightstripPc   LightArchetype = "hue_lightstrip_pc"
	HueLightstripTv   LightArchetype = "hue_lightstrip_tv"
	HuePlay           LightArchetype = "hue_play"
	HueSigne          LightArchetype = "hue_signe"
	HueTube           LightArchetype = "hue_tube"
	LargeGlobeBulb    LightArchetype = "large_globe_bulb"
	LusterBulb        LightArchetype = "luster_bulb"
	PendantLong       LightArchetype = "pendant_long"
	PendantRound      LightArchetype = "pendant_round"
	PendantSpot       LightArchetype = "pendant_spot"
	Plug              LightArchetype = "plug"
	RecessedCeiling   LightArchetype = "recessed_ceiling"
	RecessedFloor     LightArchetype = "recessed_floor"
	SingleSpot        LightArchetype = "single_spot"
	SmallGlobeBulb    LightArchetype = "small_globe_bulb"
	SpotBulb          LightArchetype = "spot_bulb"
	StringLight       LightArchetype = "string_light"
	SultanBulb        LightArchetype = "sultan_bulb"
	TableShade        LightArchetype = "table_shade"
	TableWash         LightArchetype = "table_wash"
	TriangleBulb      LightArchetype = "triangle_bulb"
	UnknownArchetype  LightArchetype = "unknown_archetype"
	VintageBulb       LightArchetype = "vintage_bulb"
	VintageCandleBulb LightArchetype = "vintage_candle_bulb"
	WallLantern       LightArchetype = "wall_lantern"
	WallShade         LightArchetype = "wall_shade"
	WallSpot          LightArchetype = "wall_spot"
	WallWasher        LightArchetype = "wall_washer"
)

// Defines values for LightGetColorGamutType.
const (
	LightGetColorGamutTypeA     LightGetColorGamutType = "A"
	LightGetColorGamutTypeB     LightGetColorGamutType = "B"
	LightGetColorGamutTypeC     LightGetColorGamutType = "C"
	LightGetColorGamutTypeOther LightGetColorGamutType = "other"
)

// Defines values for LightGetMode.
const (
	LightGetModeNormal    LightGetMode = "normal"
	LightGetModeStreaming LightGetMode = "streaming"
)

// Defines values for LightGetPowerupDimmingColorMode.
const (
	LightGetPowerupDimmingColorModeColor            LightGetPowerupDimmingColorMode = "color"
	LightGetPowerupDimmingColorModeColorTemperature LightGetPowerupDimmingColorMode = "color_temperature"
	LightGetPowerupDimmingColorModePrevious         LightGetPowerupDimmingColorMode = "previous"
)

// Defines values for LightGetPowerupDimmingMode.
const (
	LightGetPowerupDimmingModeDimming  LightGetPowerupDimmingMode = "dimming"
	LightGetPowerupDimmingModePrevious LightGetPowerupDimmingMode = "previous"
)

// Defines values for LightGetPowerupOnMode.
const (
	LightGetPowerupOnModeOn       LightGetPowerupOnMode = "on"
	LightGetPowerupOnModePrevious LightGetPowerupOnMode = "previous"
	LightGetPowerupOnModeToggle   LightGetPowerupOnMode = "toggle"
)

// Defines values for LightGetPowerupPreset.
const (
	LightGetPowerupPresetCustom      LightGetPowerupPreset = "custom"
	LightGetPowerupPresetLastOnState LightGetPowerupPreset = "last_on_state"
	LightGetPowerupPresetPowerfail   LightGetPowerupPreset = "powerfail"
	LightGetPowerupPresetSafety      LightGetPowerupPreset = "safety"
)

// Defines values for LightPutColorTemperatureDeltaAction.
const (
	LightPutColorTemperatureDeltaActionDown LightPutColorTemperatureDeltaAction = "down"
	LightPutColorTemperatureDeltaActionStop LightPutColorTemperatureDeltaAction = "stop"
	LightPutColorTemperatureDeltaActionUp   LightPutColorTemperatureDeltaAction = "up"
)

// Defines values for LightPutDimmingDeltaAction.
const (
	LightPutDimmingDeltaActionDown LightPutDimmingDeltaAction = "down"
	LightPutDimmingDeltaActionStop LightPutDimmingDeltaAction = "stop"
	LightPutDimmingDeltaActionUp   LightPutDimmingDeltaAction = "up"
)

// Defines values for LightPutMode.
const (
	LightPutModeNormal    LightPutMode = "normal"
	LightPutModeStreaming LightPutMode = "streaming"
)

// Defines values for LightPutPowerupDimmingColorMode.
const (
	LightPutPowerupDimmingColorModeColor            LightPutPowerupDimmingColorMode = "color"
	LightPutPowerupDimmingColorModeColorTemperature LightPutPowerupDimmingColorMode = "color_temperature"
	LightPutPowerupDimmingColorModePrevious         LightPutPowerupDimmingColorMode = "previous"
)

// Defines values for LightPutPowerupDimmingMode.
const (
	LightPutPowerupDimmingModeDimming  LightPutPowerupDimmingMode = "dimming"
	LightPutPowerupDimmingModePrevious LightPutPowerupDimmingMode = "previous"
)

// Defines values for LightPutPowerupOnMode.
const (
	LightPutPowerupOnModeOn       LightPutPowerupOnMode = "on"
	LightPutPowerupOnModePrevious LightPutPowerupOnMode = "previous"
	LightPutPowerupOnModeToggle   LightPutPowerupOnMode = "toggle"
)

// Defines values for LightPutPowerupPreset.
const (
	LightPutPowerupPresetCustom      LightPutPowerupPreset = "custom"
	LightPutPowerupPresetLastOnState LightPutPowerupPreset = "last_on_state"
	LightPutPowerupPresetPowerfail   LightPutPowerupPreset = "powerfail"
	LightPutPowerupPresetSafety      LightPutPowerupPreset = "safety"
)

// Defines values for LightPutSignalingSignal.
const (
	LightPutSignalingSignalAlternating LightPutSignalingSignal = "alternating"
	LightPutSignalingSignalNoSignal    LightPutSignalingSignal = "no_signal"
	LightPutSignalingSignalOnOff       LightPutSignalingSignal = "on_off"
	LightPutSignalingSignalOnOffColor  LightPutSignalingSignal = "on_off_color"
)

// Defines values for ResourceGetType.
const (
	ResourceGetTypeAuthV1                     ResourceGetType = "auth_v1"
	ResourceGetTypeBehaviorInstance           ResourceGetType = "behavior_instance"
	ResourceGetTypeBehaviorScript             ResourceGetType = "behavior_script"
	ResourceGetTypeBridge                     ResourceGetType = "bridge"
	ResourceGetTypeBridgeHome                 ResourceGetType = "bridge_home"
	ResourceGetTypeButton                     ResourceGetType = "button"
	ResourceGetTypeCameraMotion               ResourceGetType = "camera_motion"
	ResourceGetTypeContact                    ResourceGetType = "contact"
	ResourceGetTypeDevice                     ResourceGetType = "device"
	ResourceGetTypeDevicePower                ResourceGetType = "device_power"
	ResourceGetTypeEntertainment              ResourceGetType = "entertainment"
	ResourceGetTypeEntertainmentConfiguration ResourceGetType = "entertainment_configuration"
	ResourceGetTypeGeofence                   ResourceGetType = "geofence"
	ResourceGetTypeGeofenceClient             ResourceGetType = "geofence_client"
	ResourceGetTypeGeolocation                ResourceGetType = "geolocation"
	ResourceGetTypeGroupedLight               ResourceGetType = "grouped_light"
	ResourceGetTypeHomekit                    ResourceGetType = "homekit"
	ResourceGetTypeLight                      ResourceGetType = "light"
	ResourceGetTypeLightLevel                 ResourceGetType = "light_level"
	ResourceGetTypeMatter                     ResourceGetType = "matter"
	ResourceGetTypeMatterFabric               ResourceGetType = "matter_fabric"
	ResourceGetTypeMotion                     ResourceGetType = "motion"
	ResourceGetTypePublicImage                ResourceGetType = "public_image"
	ResourceGetTypeRelativeRotary             ResourceGetType = "relative_rotary"
	ResourceGetTypeRoom                       ResourceGetType = "room"
	ResourceGetTypeScene                      ResourceGetType = "scene"
	ResourceGetTypeSmartScene                 ResourceGetType = "smart_scene"
	ResourceGetTypeTamper                     ResourceGetType = "tamper"
	ResourceGetTypeTemperature                ResourceGetType = "temperature"
	ResourceGetTypeZgpConnectivity            ResourceGetType = "zgp_connectivity"
	ResourceGetTypeZigbeeBridgeConnectivity   ResourceGetType = "zigbee_bridge_connectivity"
	ResourceGetTypeZigbeeConnectivity         ResourceGetType = "zigbee_connectivity"
	ResourceGetTypeZigbeeDeviceDiscovery      ResourceGetType = "zigbee_device_discovery"
	ResourceGetTypeZone                       ResourceGetType = "zone"
)

// Defines values for ResourceIdentifierRtype.
const (
	ResourceIdentifierRtypeAuthV1                     ResourceIdentifierRtype = "auth_v1"
	ResourceIdentifierRtypeBehaviorInstance           ResourceIdentifierRtype = "behavior_instance"
	ResourceIdentifierRtypeBehaviorScript             ResourceIdentifierRtype = "behavior_script"
	ResourceIdentifierRtypeBridge                     ResourceIdentifierRtype = "bridge"
	ResourceIdentifierRtypeBridgeHome                 ResourceIdentifierRtype = "bridge_home"
	ResourceIdentifierRtypeButton                     ResourceIdentifierRtype = "button"
	ResourceIdentifierRtypeCameraMotion               ResourceIdentifierRtype = "camera_motion"
	ResourceIdentifierRtypeContact                    ResourceIdentifierRtype = "contact"
	ResourceIdentifierRtypeDevice                     ResourceIdentifierRtype = "device"
	ResourceIdentifierRtypeDevicePower                ResourceIdentifierRtype = "device_power"
	ResourceIdentifierRtypeEntertainment              ResourceIdentifierRtype = "entertainment"
	ResourceIdentifierRtypeEntertainmentConfiguration ResourceIdentifierRtype = "entertainment_configuration"
	ResourceIdentifierRtypeGeofence                   ResourceIdentifierRtype = "geofence"
	ResourceIdentifierRtypeGeofenceClient             ResourceIdentifierRtype = "geofence_client"
	ResourceIdentifierRtypeGeolocation                ResourceIdentifierRtype = "geolocation"
	ResourceIdentifierRtypeGroupedLight               ResourceIdentifierRtype = "grouped_light"
	ResourceIdentifierRtypeHomekit                    ResourceIdentifierRtype = "homekit"
	ResourceIdentifierRtypeLight                      ResourceIdentifierRtype = "light"
	ResourceIdentifierRtypeLightLevel                 ResourceIdentifierRtype = "light_level"
	ResourceIdentifierRtypeMatter                     ResourceIdentifierRtype = "matter"
	ResourceIdentifierRtypeMatterFabric               ResourceIdentifierRtype = "matter_fabric"
	ResourceIdentifierRtypeMotion                     ResourceIdentifierRtype = "motion"
	ResourceIdentifierRtypePublicImage                ResourceIdentifierRtype = "public_image"
	ResourceIdentifierRtypeRelativeRotary             ResourceIdentifierRtype = "relative_rotary"
	ResourceIdentifierRtypeRoom                       ResourceIdentifierRtype = "room"
	ResourceIdentifierRtypeScene                      ResourceIdentifierRtype = "scene"
	ResourceIdentifierRtypeSmartScene                 ResourceIdentifierRtype = "smart_scene"
	ResourceIdentifierRtypeTamper                     ResourceIdentifierRtype = "tamper"
	ResourceIdentifierRtypeTemperature                ResourceIdentifierRtype = "temperature"
	ResourceIdentifierRtypeZgpConnectivity            ResourceIdentifierRtype = "zgp_connectivity"
	ResourceIdentifierRtypeZigbeeBridgeConnectivity   ResourceIdentifierRtype = "zigbee_bridge_connectivity"
	ResourceIdentifierRtypeZigbeeConnectivity         ResourceIdentifierRtype = "zigbee_connectivity"
	ResourceIdentifierRtypeZigbeeDeviceDiscovery      ResourceIdentifierRtype = "zigbee_device_discovery"
	ResourceIdentifierRtypeZone                       ResourceIdentifierRtype = "zone"
)

// Defines values for RoomArchetype.
const (
	RoomArchetypeAttic       RoomArchetype = "attic"
	RoomArchetypeBalcony     RoomArchetype = "balcony"
	RoomArchetypeBarbecue    RoomArchetype = "barbecue"
	RoomArchetypeBathroom    RoomArchetype = "bathroom"
	RoomArchetypeBedroom     RoomArchetype = "bedroom"
	RoomArchetypeCarport     RoomArchetype = "carport"
	RoomArchetypeCloset      RoomArchetype = "closet"
	RoomArchetypeComputer    RoomArchetype = "computer"
	RoomArchetypeDining      RoomArchetype = "dining"
	RoomArchetypeDownstairs  RoomArchetype = "downstairs"
	RoomArchetypeDriveway    RoomArchetype = "driveway"
	RoomArchetypeFrontDoor   RoomArchetype = "front_door"
	RoomArchetypeGarage      RoomArchetype = "garage"
	RoomArchetypeGarden      RoomArchetype = "garden"
	RoomArchetypeGuestRoom   RoomArchetype = "guest_room"
	RoomArchetypeGym         RoomArchetype = "gym"
	RoomArchetypeHallway     RoomArchetype = "hallway"
	RoomArchetypeHome        RoomArchetype = "home"
	RoomArchetypeKidsBedroom RoomArchetype = "kids_bedroom"
	RoomArchetypeKitchen     RoomArchetype = "kitchen"
	RoomArchetypeLaundryRoom RoomArchetype = "laundry_room"
	RoomArchetypeLivingRoom  RoomArchetype = "living_room"
	RoomArchetypeLounge      RoomArchetype = "lounge"
	RoomArchetypeManCave     RoomArchetype = "man_cave"
	RoomArchetypeMusic       RoomArchetype = "music"
	RoomArchetypeNursery     RoomArchetype = "nursery"
	RoomArchetypeOffice      RoomArchetype = "office"
	RoomArchetypeOther       RoomArchetype = "other"
	RoomArchetypePool        RoomArchetype = "pool"
	RoomArchetypePorch       RoomArchetype = "porch"
	RoomArchetypeReading     RoomArchetype = "reading"
	RoomArchetypeRecreation  RoomArchetype = "recreation"
	RoomArchetypeStaircase   RoomArchetype = "staircase"
	RoomArchetypeStorage     RoomArchetype = "storage"
	RoomArchetypeStudio      RoomArchetype = "studio"
	RoomArchetypeTerrace     RoomArchetype = "terrace"
	RoomArchetypeToilet      RoomArchetype = "toilet"
	RoomArchetypeTopFloor    RoomArchetype = "top_floor"
	RoomArchetypeTv          RoomArchetype = "tv"
	RoomArchetypeUpstairs    RoomArchetype = "upstairs"
)

// Defines values for SceneGetStatusActive.
const (
	SceneGetStatusActiveDynamicPalette SceneGetStatusActive = "dynamic_palette"
	SceneGetStatusActiveInactive       SceneGetStatusActive = "inactive"
	SceneGetStatusActiveStatic         SceneGetStatusActive = "static"
)

// Defines values for SceneGetType.
const (
	SceneGetTypeScene SceneGetType = "scene"
)

// Defines values for ScenePostType.
const (
	ScenePostTypeScene ScenePostType = "scene"
)

// Defines values for ScenePutRecallAction.
const (
	ScenePutRecallActionActive         ScenePutRecallAction = "active"
	ScenePutRecallActionDynamicPalette ScenePutRecallAction = "dynamic_palette"
	ScenePutRecallActionStatic         ScenePutRecallAction = "static"
)

// Defines values for ScenePutType.
const (
	ScenePutTypeScene ScenePutType = "scene"
)

// Defines values for SupportedDynamicStatus.
const (
	DynamicPalette SupportedDynamicStatus = "dynamic_palette"
	None           SupportedDynamicStatus = "none"
)

// Defines values for SupportedEffects.
const (
	SupportedEffectsCandle   SupportedEffects = "candle"
	SupportedEffectsFire     SupportedEffects = "fire"
	SupportedEffectsGlisten  SupportedEffects = "glisten"
	SupportedEffectsNoEffect SupportedEffects = "no_effect"
	SupportedEffectsOpal     SupportedEffects = "opal"
	SupportedEffectsPrism    SupportedEffects = "prism"
	SupportedEffectsSparkle  SupportedEffects = "sparkle"
)

// Defines values for SupportedGradientMode.
const (
	InterpolatedPalette         SupportedGradientMode = "interpolated_palette"
	InterpolatedPaletteMirrored SupportedGradientMode = "interpolated_palette_mirrored"
	RandomPixelated             SupportedGradientMode = "random_pixelated"
)

// Defines values for SupportedSignals.
const (
	SupportedSignalsAlternating SupportedSignals = "alternating"
	SupportedSignalsNoSignal    SupportedSignals = "no_signal"
	SupportedSignalsOnOff       SupportedSignals = "on_off"
	SupportedSignalsOnOffColor  SupportedSignals = "on_off_color"
)

// Defines values for SupportedTimedEffects.
const (
	SupportedTimedEffectsNoEffect SupportedTimedEffects = "no_effect"
	SupportedTimedEffectsSunrise  SupportedTimedEffects = "sunrise"
)

// ActionGet defines model for ActionGet.
type ActionGet struct {
	// Action The action to be executed on recall
	Action *struct {
		Color *Color `json:"color,omitempty"`

		// ColorTemperature color temperature in mirek or null when the light color is not in the ct spectrum
		ColorTemperature *Mirek   `json:"color_temperature,omitempty"`
		Dimming          *Dimming `json:"dimming,omitempty"`

		// Effects Basic feature containing effect properties.
		Effects *struct {
			Effect *SupportedEffects `json:"effect,omitempty"`
		} `json:"effects,omitempty"`

		// Gradient Basic feature containing gradient properties.
		Gradient *Gradient `json:"gradient,omitempty"`
		On       *On       `json:"on,omitempty"`
	} `json:"action,omitempty"`

	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1   *string             `json:"id_v1,omitempty"`
	Owner  *ResourceIdentifier `json:"owner,omitempty"`
	Target *ResourceIdentifier `json:"target,omitempty"`

	// Type Type of the supported resources
	Type *string `json:"type,omitempty"`
}

// ActionPost defines model for ActionPost.
type ActionPost struct {
	// Action The action to be executed on recall
	Action struct {
		Color *Color `json:"color,omitempty"`

		// ColorTemperature color temperature in mirek or null when the light color is not in the ct spectrum
		ColorTemperature *Mirek   `json:"color_temperature,omitempty"`
		Dimming          *Dimming `json:"dimming,omitempty"`
		Dynamics         *struct {
			// Duration Duration of a light transition or timed effects in ms.
			Duration *int `json:"duration,omitempty"`
		} `json:"dynamics,omitempty"`

		// Effects Basic feature containing effect properties.
		Effects *struct {
			Effect *SupportedEffects `json:"effect,omitempty"`
		} `json:"effects,omitempty"`

		// Gradient Basic feature containing gradient properties.
		Gradient *Gradient `json:"gradient,omitempty"`
		On       *On       `json:"on,omitempty"`
	} `json:"action"`
	Target ResourceIdentifier `json:"target"`
}

// ApiResponse defines model for ApiResponse.
type ApiResponse struct {
	Data   *[]interface{} `json:"data,omitempty"`
	Errors *[]Error       `json:"errors,omitempty"`
}

// BridgeGet defines model for BridgeGet.
type BridgeGet struct {
	// BridgeId Unique identifier of the bridge as printed on the device. Lower case (shouldn't it be upper case?)
	BridgeId *string `json:"bridge_id,omitempty"`

	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1     *string             `json:"id_v1,omitempty"`
	Owner    *ResourceIdentifier `json:"owner,omitempty"`
	TimeZone *struct {
		// TimeZone Time zone where the user's home is located (as Olson ID).
		TimeZone *string `json:"time_zone,omitempty"`
	} `json:"time_zone,omitempty"`
	Type *BridgeGetType `json:"type,omitempty"`
}

// BridgeGetType defines model for BridgeGet.Type.
type BridgeGetType string

// BridgeHomeGet defines model for BridgeHomeGet.
type BridgeHomeGet struct {
	// Children Child devices/services to group by the derived group.
	Children *[]ResourceIdentifier `json:"children,omitempty"`

	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1 *string `json:"id_v1,omitempty"`

	// Services References all services aggregating control and state of children in the group.
	// This includes all services grouped in the group hierarchy given by child relation.
	// This includes all services of a device grouped in the group hierarchy given by child relation.
	// Aggregation is per service type, ie every service type which can be grouped has a corresponding definition
	// of grouped type Supported types: – grouped_light
	Services *[]ResourceIdentifier `json:"services,omitempty"`
	Type     *BridgeHomeGetType    `json:"type,omitempty"`
}

// BridgeHomeGetType defines model for BridgeHomeGet.Type.
type BridgeHomeGetType string

// BridgePut defines model for BridgePut.
type BridgePut struct {
	Type *BridgePutType `json:"type,omitempty"`
}

// BridgePutType defines model for BridgePut.Type.
type BridgePutType string

// Brightness Brightness percentage. value cannot be 0, writing 0 changes it to lowest possible brightness
type Brightness = float32

// Color defines model for Color.
type Color struct {
	// Xy CIE XY gamut position
	Xy *GamutPosition `json:"xy,omitempty"`
}

// ColorPaletteGet defines model for ColorPaletteGet.
type ColorPaletteGet struct {
	Color   *Color   `json:"color,omitempty"`
	Dimming *Dimming `json:"dimming,omitempty"`
}

// ColorTemperaturePaletteGet defines model for ColorTemperaturePaletteGet.
type ColorTemperaturePaletteGet struct {
	ColorTemperature *struct {
		// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
		Mirek *Mirek `json:"mirek,omitempty"`
	} `json:"color_temperature,omitempty"`
	Dimming *Dimming `json:"dimming,omitempty"`
}

// ColorTemperaturePalettePost defines model for ColorTemperaturePalettePost.
type ColorTemperaturePalettePost struct {
	ColorTemperature *struct {
		// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
		Mirek *Mirek `json:"mirek,omitempty"`
	} `json:"color_temperature,omitempty"`
	Dimming *Dimming `json:"dimming,omitempty"`
}

// Dimming defines model for Dimming.
type Dimming struct {
	// Brightness Brightness percentage. value cannot be 0, writing 0 changes it to lowest possible brightness
	Brightness *Brightness `json:"brightness,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Description a human-readable explanation specific to this occurrence of the problem.
	Description *string `json:"description,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Errors *[]Error `json:"errors,omitempty"`
}

// GamutPosition CIE XY gamut position
type GamutPosition struct {
	// X X position in color gamut
	X *float32 `json:"x,omitempty"`

	// Y y position in color gamut
	Y *float32 `json:"y,omitempty"`
}

// Gradient Basic feature containing gradient properties.
type Gradient struct {
	// Mode Mode in which the points are currently being deployed. If not provided during PUT/POST it will be defaulted to interpolated_palette
	Mode *SupportedGradientMode `json:"mode,omitempty"`

	// Points Collection of gradients points. For control of the gradient points through a PUT a minimum of 2 points need to be provided.
	Points *[]Color `json:"points,omitempty"`
}

// LightArchetype Light archetype
type LightArchetype string

// LightGet defines model for LightGet.
type LightGet struct {
	// Alert TODO
	Alert *map[string]interface{} `json:"alert,omitempty"`
	Color *struct {
		// Gamut Color gamut of color bulb. Some bulbs do not properly return the Gamut information. In this case this is not present.
		Gamut *struct {
			// Blue CIE XY gamut position
			Blue *GamutPosition `json:"blue,omitempty"`

			// Green CIE XY gamut position
			Green *GamutPosition `json:"green,omitempty"`

			// Red CIE XY gamut position
			Red *GamutPosition `json:"red,omitempty"`
		} `json:"gamut,omitempty"`

		// GamutType The gammut types supported by hue – A Gamut of early Philips color-only products – B Limited gamut of first Hue color products – C Richer color gamut of Hue white and color ambiance products – other Color gamut of non-hue products with non-hue gamuts resp w/o gamut
		GamutType *LightGetColorGamutType `json:"gamut_type,omitempty"`

		// Xy CIE XY gamut position
		Xy *GamutPosition `json:"xy,omitempty"`
	} `json:"color,omitempty"`
	ColorTemperature *struct {
		// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
		Mirek       *int `json:"mirek,omitempty"`
		MirekSchema *struct {
			// MirekMaximum maximum color temperature this light supports
			MirekMaximum *int `json:"mirek_maximum,omitempty"`

			// MirekMinimum minimum color temperature this light supports
			MirekMinimum *int `json:"mirek_minimum,omitempty"`
		} `json:"mirek_schema,omitempty"`

		// MirekValid Indication whether the value presented in mirek is valid
		MirekValid *bool `json:"mirek_valid,omitempty"`
	} `json:"color_temperature,omitempty"`
	Dimming *struct {
		// Brightness Brightness percentage. value cannot be 0, writing 0 changes it to lowest possible brightness
		Brightness *Brightness `json:"brightness,omitempty"`

		// MinDimLevel Percentage of the maximum lumen the device outputs on minimum brightness
		MinDimLevel *float32 `json:"min_dim_level,omitempty"`
	} `json:"dimming,omitempty"`
	Dynamics *struct {
		// Speed speed of dynamic palette or effect. The speed is valid for the dynamic palette if the status is dynamic_palette or for the corresponding effect listed in status. In case of status none, the speed is not valid
		Speed *float32 `json:"speed,omitempty"`

		// SpeedValid Indicates whether the value presented in speed is valid
		SpeedValid *bool `json:"speed_valid,omitempty"`

		// Status Current status of the lamp with dynamics.
		Status *SupportedDynamicStatus `json:"status,omitempty"`

		// StatusValues Statuses in which a lamp could be when playing dynamics.
		StatusValues *[]SupportedDynamicStatus `json:"status_values,omitempty"`
	} `json:"dynamics,omitempty"`

	// Effects Basic feature containing effect properties.
	Effects *struct {
		Effect *SupportedEffects `json:"effect,omitempty"`

		// EffectValues Possible status values in which a light could be when playing an effect.
		EffectValues *[]SupportedEffects `json:"effect_values,omitempty"`
		Status       *SupportedEffects   `json:"status,omitempty"`

		// StatusValues Possible status values in which a light could be when playing an effect.
		StatusValues *[]SupportedEffects `json:"status_values,omitempty"`
	} `json:"effects,omitempty"`
	Gradient *struct {
		// Mode Mode in which the points are currently being deployed. If not provided during PUT/POST it will be defaulted to interpolated_palette
		Mode *SupportedGradientMode `json:"mode,omitempty"`

		// ModeValues Modes a gradient device can deploy the gradient palette of colors
		ModeValues *[]SupportedGradientMode `json:"mode_values,omitempty"`

		// PixelCount Number of pixels in the device
		PixelCount *int `json:"pixel_count,omitempty"`

		// Points Collection of gradients points. For control of the gradient points through a PUT a minimum of 2 points need to be provided.
		Points *[]Color `json:"points,omitempty"`

		// PointsCapable Number of color points that gradient lamp is capable of showing with gradience.
		PointsCapable *int `json:"points_capable,omitempty"`
	} `json:"gradient,omitempty"`

	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1 *string `json:"id_v1,omitempty"`

	// Metadata Deprecated, use metadata on device level
	Metadata *struct {
		// Archetype Light archetype
		Archetype *LightArchetype `json:"archetype,omitempty"`

		// FixedMired A fixed mired value of the white lamp
		FixedMired *int `json:"fixed_mired,omitempty"`

		// Name Human readable name of a resource
		Name *string `json:"name,omitempty"`
	} `json:"metadata,omitempty"`
	Mode  *LightGetMode       `json:"mode,omitempty"`
	On    *On                 `json:"on,omitempty"`
	Owner *ResourceIdentifier `json:"owner,omitempty"`

	// Powerup Feature containing properties to configure powerup behaviour of a lightsource.
	Powerup *struct {
		// Configured Indicates if the shown values have been configured in the lightsource.
		Configured *bool `json:"configured,omitempty"`
		Dimming    *struct {
			Color *struct {
				ColorTemperature *struct {
					Color *Color `json:"color,omitempty"`

					// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
					Mirek *Mirek `json:"mirek,omitempty"`
				} `json:"color_temperature,omitempty"`

				// Mode State to activate after powerup. Availability of “color_temperature” and “color” modes depend on the capabilities of the lamp. Colortemperature will set the colortemperature to the specified value after power up. When setting color_temperature, the color_temperature property must be included Color will set the color tot he specified value after power up. When setting color mode, the color property must be included Previous will set color to the state it was in before powering off.
				Mode *LightGetPowerupDimmingColorMode `json:"mode,omitempty"`
			} `json:"color,omitempty"`
			Dimming *Dimming `json:"dimming,omitempty"`

			// Mode Dimming will set the brightness to the specified value after power up.
			// When setting mode “dimming”, the dimming property must be included.
			// Previous will set brightness to the state it was in before powering off.
			Mode *LightGetPowerupDimmingMode `json:"mode,omitempty"`
		} `json:"dimming,omitempty"`
		On *struct {
			// Mode State to activate after powerup.
			// On will use the value specified in the “on” property.
			// When setting mode “on”, the on property must be included.
			// Toggle will alternate between on and off on each subsequent power toggle.
			// Previous will return to the state it was in before powering off.
			Mode *LightGetPowerupOnMode `json:"mode,omitempty"`
			On   *On                    `json:"on,omitempty"`
		} `json:"on,omitempty"`

		// Preset When setting the custom preset the additional properties can be set. For all other presets, no other properties can be included.
		Preset *LightGetPowerupPreset `json:"preset,omitempty"`
	} `json:"powerup,omitempty"`

	// Signaling Feature containing signaling properties.
	Signaling *struct {
		// Colors Colors that were provided for the active effect.
		Colors *[]Color `json:"colors,omitempty"`

		// EstimatedEnd Timestamp indicating when the active signal is expected to end. Value is not set if there is no_signal
		EstimatedEnd *int                `json:"estimated_end,omitempty"`
		SignalValues *[]SupportedSignals `json:"signal_values,omitempty"`
	} `json:"signaling,omitempty"`

	// TimedEffects Basic feature containing timed effect properties.
	TimedEffects *struct {
		// Duration Duration is mandatory when timed effect is set except for no_effect. Resolution decreases for a larger duration. e.g Effects with duration smaller than a minute will be rounded to a resolution of 1s, while effects with duration larger than an hour will be arounded up to a resolution of 300s. Duration has a max of 21600000 ms.
		Duration *int `json:"duration,omitempty"`

		// Effect Current status values the light is in regarding timed effects
		Effect *SupportedTimedEffects `json:"effect,omitempty"`

		// EffectValues Possible timed effect values you can set in a light.
		EffectValues *[]SupportedTimedEffects `json:"effect_values,omitempty"`

		// Status Current status values the light is in regarding timed effects
		Status *SupportedTimedEffects `json:"status,omitempty"`

		// StatusValues Possible status values in which a light could be when playing a timed effect.
		StatusValues *[]SupportedTimedEffects `json:"status_values,omitempty"`
	} `json:"timed_effects,omitempty"`

	// Type Type of the supported resources
	Type *string `json:"type,omitempty"`
}

// LightGetColorGamutType The gammut types supported by hue – A Gamut of early Philips color-only products – B Limited gamut of first Hue color products – C Richer color gamut of Hue white and color ambiance products – other Color gamut of non-hue products with non-hue gamuts resp w/o gamut
type LightGetColorGamutType string

// LightGetMode defines model for LightGet.Mode.
type LightGetMode string

// LightGetPowerupDimmingColorMode State to activate after powerup. Availability of “color_temperature” and “color” modes depend on the capabilities of the lamp. Colortemperature will set the colortemperature to the specified value after power up. When setting color_temperature, the color_temperature property must be included Color will set the color tot he specified value after power up. When setting color mode, the color property must be included Previous will set color to the state it was in before powering off.
type LightGetPowerupDimmingColorMode string

// LightGetPowerupDimmingMode Dimming will set the brightness to the specified value after power up.
// When setting mode “dimming”, the dimming property must be included.
// Previous will set brightness to the state it was in before powering off.
type LightGetPowerupDimmingMode string

// LightGetPowerupOnMode State to activate after powerup.
// On will use the value specified in the “on” property.
// When setting mode “on”, the on property must be included.
// Toggle will alternate between on and off on each subsequent power toggle.
// Previous will return to the state it was in before powering off.
type LightGetPowerupOnMode string

// LightGetPowerupPreset When setting the custom preset the additional properties can be set. For all other presets, no other properties can be included.
type LightGetPowerupPreset string

// LightPut defines model for LightPut.
type LightPut struct {
	Alert *struct {
		Action *string `json:"action,omitempty"`
	} `json:"alert,omitempty"`

	// Color CIE XY gamut position
	Color            *GamutPosition `json:"color,omitempty"`
	ColorTemperature *struct {
		// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
		Mirek *Mirek `json:"mirek,omitempty"`
	} `json:"color_temperature,omitempty"`
	ColorTemperatureDelta *struct {
		Action *LightPutColorTemperatureDeltaAction `json:"action,omitempty"`

		// MirekDelta Mirek delta to current mirek. Clip at mirek_minimum and mirek_maximum of mirek_schema.
		MirekDelta *int `json:"mirek_delta,omitempty"`
	} `json:"color_temperature_delta,omitempty"`
	Dimming      *Dimming `json:"dimming,omitempty"`
	DimmingDelta *struct {
		Action *LightPutDimmingDeltaAction `json:"action,omitempty"`

		// BrightnessDelta Brightness percentage of full-scale increase delta to current dimlevel. Clip at Max-level or Min-level.
		BrightnessDelta *float32 `json:"brightness_delta,omitempty"`
	} `json:"dimming_delta,omitempty"`
	Dynamics *struct {
		// Duration Duration of a light transition or timed effects in ms.
		Duration *int `json:"duration,omitempty"`

		// Speed speed of dynamic palette or effect. The speed is valid for the dynamic palette if the status is dynamic_palette or for the corresponding effect listed in status. In case of status none, the speed is not valid
		Speed *float32 `json:"speed,omitempty"`
	} `json:"dynamics,omitempty"`

	// Effects Basic feature containing effect properties.
	Effects *struct {
		Effect *SupportedEffects `json:"effect,omitempty"`
	} `json:"effects,omitempty"`

	// Gradient Basic feature containing gradient properties.
	Gradient *Gradient     `json:"gradient,omitempty"`
	Mode     *LightPutMode `json:"mode,omitempty"`
	On       *On           `json:"on,omitempty"`

	// Powerup Feature containing properties to configure powerup behaviour of a lightsource.
	Powerup *struct {
		// Configured Indicates if the shown values have been configured in the lightsource.
		Configured *bool `json:"configured,omitempty"`
		Dimming    *struct {
			Color *struct {
				ColorTemperature *struct {
					Color *Color `json:"color,omitempty"`

					// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
					Mirek *Mirek `json:"mirek,omitempty"`
				} `json:"color_temperature,omitempty"`

				// Mode State to activate after powerup. Availability of “color_temperature” and “color” modes depend on the capabilities of the lamp. Colortemperature will set the colortemperature to the specified value after power up. When setting color_temperature, the color_temperature property must be included Color will set the color tot he specified value after power up. When setting color mode, the color property must be included Previous will set color to the state it was in before powering off.
				Mode *LightPutPowerupDimmingColorMode `json:"mode,omitempty"`
			} `json:"color,omitempty"`

			// Dimming Brightness percentage. value cannot be 0, writing 0 changes it to lowest possible brightness
			Dimming *Brightness `json:"dimming,omitempty"`

			// Mode Dimming will set the brightness to the specified value after power up.
			// When setting mode “dimming”, the dimming property must be included.
			// Previous will set brightness to the state it was in before powering off.
			Mode *LightPutPowerupDimmingMode `json:"mode,omitempty"`
		} `json:"dimming,omitempty"`
		On *struct {
			// Mode State to activate after powerup.
			// On will use the value specified in the “on” property.
			// When setting mode “on”, the on property must be included.
			// Toggle will alternate between on and off on each subsequent power toggle.
			// Previous will return to the state it was in before powering off.
			Mode *LightPutPowerupOnMode `json:"mode,omitempty"`
			On   *On                    `json:"on,omitempty"`
		} `json:"on,omitempty"`

		// Preset When setting the custom preset the additional properties can be set. For all other presets, no other properties can be included.
		Preset *LightPutPowerupPreset `json:"preset,omitempty"`
	} `json:"powerup,omitempty"`

	// Signaling Feature containing signaling properties.
	Signaling *struct {
		// Colors Colors that were provided for the active effect.
		Colors *[]Color `json:"colors,omitempty"`

		// Duration Duration has a max of 65534000 ms and a stepsize of 1 second. Values inbetween steps will be rounded. Duration is ignored for no_signal.
		Duration *int                     `json:"duration,omitempty"`
		Signal   *LightPutSignalingSignal `json:"signal,omitempty"`
	} `json:"signaling,omitempty"`

	// TimedEffects Basic feature containing timed effect properties.
	TimedEffects *struct {
		// Duration Duration is mandatory when timed effect is set except for no_effect. Resolution decreases for a larger duration. e.g Effects with duration smaller than a minute will be rounded to a resolution of 1s, while effects with duration larger than an hour will be arounded up to a resolution of 300s. Duration has a max of 21600000 ms.
		Duration *int `json:"duration,omitempty"`

		// Effect Current status values the light is in regarding timed effects
		Effect *SupportedTimedEffects `json:"effect,omitempty"`
	} `json:"timed_effects,omitempty"`

	// Type Type of the supported resources (always `light` here)
	Type *string `json:"type,omitempty"`
}

// LightPutColorTemperatureDeltaAction defines model for LightPut.ColorTemperatureDelta.Action.
type LightPutColorTemperatureDeltaAction string

// LightPutDimmingDeltaAction defines model for LightPut.DimmingDelta.Action.
type LightPutDimmingDeltaAction string

// LightPutMode defines model for LightPut.Mode.
type LightPutMode string

// LightPutPowerupDimmingColorMode State to activate after powerup. Availability of “color_temperature” and “color” modes depend on the capabilities of the lamp. Colortemperature will set the colortemperature to the specified value after power up. When setting color_temperature, the color_temperature property must be included Color will set the color tot he specified value after power up. When setting color mode, the color property must be included Previous will set color to the state it was in before powering off.
type LightPutPowerupDimmingColorMode string

// LightPutPowerupDimmingMode Dimming will set the brightness to the specified value after power up.
// When setting mode “dimming”, the dimming property must be included.
// Previous will set brightness to the state it was in before powering off.
type LightPutPowerupDimmingMode string

// LightPutPowerupOnMode State to activate after powerup.
// On will use the value specified in the “on” property.
// When setting mode “on”, the on property must be included.
// Toggle will alternate between on and off on each subsequent power toggle.
// Previous will return to the state it was in before powering off.
type LightPutPowerupOnMode string

// LightPutPowerupPreset When setting the custom preset the additional properties can be set. For all other presets, no other properties can be included.
type LightPutPowerupPreset string

// LightPutSignalingSignal defines model for LightPut.Signaling.Signal.
type LightPutSignalingSignal string

// Mirek color temperature in mirek or null when the light color is not in the ct spectrum
type Mirek = int

// On defines model for On.
type On struct {
	// On On/Off state of the light on=true, off=false
	On *bool `json:"on,omitempty"`
}

// Resource Common resource properties
type Resource struct {
	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1 *string `json:"id_v1,omitempty"`

	// Type Type of the supported resources
	Type *string `json:"type,omitempty"`
}

// ResourceGet defines model for ResourceGet.
type ResourceGet struct {
	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1  *string             `json:"id_v1,omitempty"`
	Owner *ResourceIdentifier `json:"owner,omitempty"`

	// Type Type of the supported resources
	Type *ResourceGetType `json:"type,omitempty"`
}

// ResourceGetType Type of the supported resources
type ResourceGetType string

// ResourceIdentifier defines model for ResourceIdentifier.
type ResourceIdentifier struct {
	// Rid The unique id of the referenced resource
	Rid *string `json:"rid,omitempty"`

	// Rtype The type of the referenced resource
	Rtype *ResourceIdentifierRtype `json:"rtype,omitempty"`
}

// ResourceIdentifierRtype The type of the referenced resource
type ResourceIdentifierRtype string

// ResourceOwned defines model for ResourceOwned.
type ResourceOwned struct {
	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1  *string             `json:"id_v1,omitempty"`
	Owner *ResourceIdentifier `json:"owner,omitempty"`

	// Type Type of the supported resources
	Type *string `json:"type,omitempty"`
}

// RoomArchetype Possible archetypes of a room
type RoomArchetype string

// RoomGet defines model for RoomGet.
type RoomGet struct {
	// Children Child devices/services to group by the derived group
	Children *[]ResourceIdentifier `json:"children,omitempty"`

	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1 *string `json:"id_v1,omitempty"`

	// Metadata configuration object for a room
	Metadata *struct {
		// Archetype Possible archetypes of a room
		Archetype *RoomArchetype `json:"archetype,omitempty"`

		// Name Human readable name of a resource
		Name *string `json:"name,omitempty"`
	} `json:"metadata,omitempty"`

	// Services References all services aggregating control and state of children in the group.
	// This includes all services grouped in the group hierarchy given by child relation.
	// This includes all services of a device grouped in the group hierarchy given by child relation.
	// Aggregation is per service type, ie every service type which can be grouped has a corresponding definition of
	// grouped type.
	// Supported types: – grouped_light
	Services *[]ResourceIdentifier `json:"services,omitempty"`

	// Type Type of the supported resources
	Type *string `json:"type,omitempty"`
}

// RoomPut defines model for RoomPut.
type RoomPut struct {
	// Children Child devices/services to group by the derived group
	Children *[]ResourceIdentifier `json:"children,omitempty"`

	// Metadata configuration object for a room
	Metadata *struct {
		// Archetype Possible archetypes of a room
		Archetype *RoomArchetype `json:"archetype,omitempty"`

		// Name Human readable name of a resource
		Name *string `json:"name,omitempty"`
	} `json:"metadata,omitempty"`

	// Type Type of the supported resources (always `room` here)
	Type *string `json:"type,omitempty"`
}

// SceneGet defines model for SceneGet.
type SceneGet struct {
	// Actions List of actions to be executed synchronously on recall
	Actions *[]ActionGet `json:"actions,omitempty"`

	// AutoDynamic Indicates whether to automatically start the scene dynamically on active recall
	AutoDynamic *bool `json:"auto_dynamic,omitempty"`

	// Id Unique identifier representing a specific resource instance
	Id *string `json:"id,omitempty"`

	// IdV1 Clip v1 resource identifier
	IdV1     *string `json:"id_v1,omitempty"`
	Metadata *struct {
		// Appdata Application specific data. Free format string.
		Appdata *string             `json:"appdata,omitempty"`
		Image   *ResourceIdentifier `json:"image,omitempty"`

		// Name Human readable name of a resource
		Name *string `json:"name,omitempty"`
	} `json:"metadata,omitempty"`
	Owner *ResourceIdentifier `json:"owner,omitempty"`

	// Palette Group of colors that describe the palette of colors to be used when playing dynamics
	Palette *struct {
		Color            *[]ColorPaletteGet            `json:"color,omitempty"`
		ColorTemperature *[]ColorTemperaturePaletteGet `json:"color_temperature,omitempty"`
		Dimming          *[]Dimming                    `json:"dimming,omitempty"`
		Effects          *[]struct {
			Effect *SupportedEffects `json:"effect,omitempty"`
		} `json:"effects,omitempty"`
	} `json:"palette,omitempty"`

	// Speed Speed of dynamic palette for this scene
	Speed  *float32 `json:"speed,omitempty"`
	Status *struct {
		Active *SceneGetStatusActive `json:"active,omitempty"`
	} `json:"status,omitempty"`
	Type *SceneGetType `json:"type,omitempty"`
}

// SceneGetStatusActive defines model for SceneGet.Status.Active.
type SceneGetStatusActive string

// SceneGetType defines model for SceneGet.Type.
type SceneGetType string

// ScenePost defines model for ScenePost.
type ScenePost struct {
	// Actions List of actions to be executed synchronously on recall
	Actions []ActionPost `json:"actions"`

	// AutoDynamic Indicates whether to automatically start the scene dynamically on active recall
	AutoDynamic *bool              `json:"auto_dynamic,omitempty"`
	Group       ResourceIdentifier `json:"group"`
	Metadata    struct {
		// Appdata Application specific data. Free format string.
		Appdata *string             `json:"appdata,omitempty"`
		Image   *ResourceIdentifier `json:"image,omitempty"`

		// Name Human readable name of a resource
		Name *string `json:"name,omitempty"`
	} `json:"metadata"`

	// Palette Group of colors that describe the palette of colors to be used when playing dynamics
	Palette *struct {
		Color            *[]ColorPaletteGet             `json:"color,omitempty"`
		ColorTemperature *[]ColorTemperaturePalettePost `json:"color_temperature,omitempty"`
		Dimming          *[]Dimming                     `json:"dimming,omitempty"`
		Effects          *[]struct {
			Effect *SupportedEffects `json:"effect,omitempty"`
		} `json:"effects,omitempty"`
	} `json:"palette,omitempty"`

	// Speed Speed of dynamic palette for this scene
	Speed *float32       `json:"speed,omitempty"`
	Type  *ScenePostType `json:"type,omitempty"`
}

// ScenePostType defines model for ScenePost.Type.
type ScenePostType string

// ScenePut defines model for ScenePut.
type ScenePut struct {
	// Actions List of actions to be executed synchronously on recall
	Actions []ActionPost `json:"actions"`

	// AutoDynamic Indicates whether to automatically start the scene dynamically on active recall
	AutoDynamic *bool `json:"auto_dynamic,omitempty"`
	Metadata    struct {
		// Appdata Application specific data. Free format string.
		Appdata *string             `json:"appdata,omitempty"`
		Image   *ResourceIdentifier `json:"image,omitempty"`

		// Name Human readable name of a resource
		Name *string `json:"name,omitempty"`
	} `json:"metadata"`

	// Palette Group of colors that describe the palette of colors to be used when playing dynamics
	Palette *struct {
		Color            *[]ColorPaletteGet             `json:"color,omitempty"`
		ColorTemperature *[]ColorTemperaturePalettePost `json:"color_temperature,omitempty"`
		Dimming          *[]Dimming                     `json:"dimming,omitempty"`
		Effects          *[]struct {
			Effect *SupportedEffects `json:"effect,omitempty"`
		} `json:"effects,omitempty"`
	} `json:"palette,omitempty"`
	Recall *struct {
		// Action When writing active, the actions in the scene are executed on the target. dynamic_palette starts dynamic scene with colors in the Palette object.
		Action  *ScenePutRecallAction `json:"action,omitempty"`
		Dimming *Dimming              `json:"dimming,omitempty"`

		// Duration Transition to the scene within the timeframe given by duration
		Duration *int `json:"duration,omitempty"`
	} `json:"recall,omitempty"`

	// Speed Speed of dynamic palette for this scene
	Speed *float32      `json:"speed,omitempty"`
	Type  *ScenePutType `json:"type,omitempty"`
}

// ScenePutRecallAction When writing active, the actions in the scene are executed on the target. dynamic_palette starts dynamic scene with colors in the Palette object.
type ScenePutRecallAction string

// ScenePutType defines model for ScenePut.Type.
type ScenePutType string

// SupportedDynamicStatus Current status of the lamp with dynamics.
type SupportedDynamicStatus string

// SupportedEffects defines model for SupportedEffects.
type SupportedEffects string

// SupportedGradientMode Mode in which the points are currently being deployed. If not provided during PUT/POST it will be defaulted to interpolated_palette
type SupportedGradientMode string

// SupportedSignals Indicates which signal is currently active.
type SupportedSignals string

// SupportedTimedEffects Current status values the light is in regarding timed effects
type SupportedTimedEffects string

// Response defines model for response.
type Response struct {
	Success *struct {
		Clientkey *string `json:"clientkey,omitempty"`
		Username  *string `json:"username,omitempty"`
	} `json:"success,omitempty"`
}

// Conflict defines model for Conflict.
type Conflict = ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// InsufficientStorage defines model for InsufficientStorage.
type InsufficientStorage = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ErrorResponse

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// ServiceUnavailable defines model for ServiceUnavailable.
type ServiceUnavailable = ErrorResponse

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// AuthenticateJSONBody defines parameters for Authenticate.
type AuthenticateJSONBody struct {
	Devicetype        *string `json:"devicetype,omitempty"`
	Generateclientkey *bool   `json:"generateclientkey,omitempty"`
}

// AuthenticateJSONRequestBody defines body for Authenticate for application/json ContentType.
type AuthenticateJSONRequestBody AuthenticateJSONBody

// UpdateBridgeJSONRequestBody defines body for UpdateBridge for application/json ContentType.
type UpdateBridgeJSONRequestBody = BridgePut

// UpdateLightJSONRequestBody defines body for UpdateLight for application/json ContentType.
type UpdateLightJSONRequestBody = LightPut

// CreateRoomJSONRequestBody defines body for CreateRoom for application/json ContentType.
type CreateRoomJSONRequestBody = RoomPut

// UpdateRoomJSONRequestBody defines body for UpdateRoom for application/json ContentType.
type UpdateRoomJSONRequestBody = RoomPut

// CreateSceneJSONRequestBody defines body for CreateScene for application/json ContentType.
type CreateSceneJSONRequestBody = ScenePost

// UpdateSceneJSONRequestBody defines body for UpdateScene for application/json ContentType.
type UpdateSceneJSONRequestBody = ScenePut

// CreateZoneJSONRequestBody defines body for CreateZone for application/json ContentType.
type CreateZoneJSONRequestBody = RoomPut

// UpdateZoneJSONRequestBody defines body for UpdateZone for application/json ContentType.
type UpdateZoneJSONRequestBody = RoomPut

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AuthenticateWithBody request with any body
	AuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Authenticate(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridges request
	GetBridges(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridge request
	GetBridge(ctx context.Context, bridgeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBridgeWithBody request with any body
	UpdateBridgeWithBody(ctx context.Context, bridgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBridge(ctx context.Context, bridgeId string, body UpdateBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridgeHomes request
	GetBridgeHomes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridgeHome request
	GetBridgeHome(ctx context.Context, bridgeHomeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLights request
	GetLights(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLight request
	GetLight(ctx context.Context, lightId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLightWithBody request with any body
	UpdateLightWithBody(ctx context.Context, lightId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLight(ctx context.Context, lightId string, body UpdateLightJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRooms request
	GetRooms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoomWithBody request with any body
	CreateRoomWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoom(ctx context.Context, body CreateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoom request
	DeleteRoom(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoom request
	GetRoom(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoomWithBody request with any body
	UpdateRoomWithBody(ctx context.Context, roomId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoom(ctx context.Context, roomId string, body UpdateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScenes request
	GetScenes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSceneWithBody request with any body
	CreateSceneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScene(ctx context.Context, body CreateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScene request
	DeleteScene(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScene request
	GetScene(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSceneWithBody request with any body
	UpdateSceneWithBody(ctx context.Context, sceneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateScene(ctx context.Context, sceneId string, body UpdateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZones request
	GetZones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateZoneWithBody request with any body
	CreateZoneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateZone(ctx context.Context, body CreateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteZone request
	DeleteZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZone request
	GetZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateZoneWithBody request with any body
	UpdateZoneWithBody(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateZone(ctx context.Context, zoneId string, body UpdateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authenticate(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridges(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridge(ctx context.Context, bridgeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeRequest(c.Server, bridgeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBridgeWithBody(ctx context.Context, bridgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBridgeRequestWithBody(c.Server, bridgeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBridge(ctx context.Context, bridgeId string, body UpdateBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBridgeRequest(c.Server, bridgeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridgeHomes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeHomesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridgeHome(ctx context.Context, bridgeHomeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeHomeRequest(c.Server, bridgeHomeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLights(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLightsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLight(ctx context.Context, lightId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLightRequest(c.Server, lightId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLightWithBody(ctx context.Context, lightId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLightRequestWithBody(c.Server, lightId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLight(ctx context.Context, lightId string, body UpdateLightJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLightRequest(c.Server, lightId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRooms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoomsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoomWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoomRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoom(ctx context.Context, body CreateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoomRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoom(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoomRequest(c.Server, roomId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoom(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoomRequest(c.Server, roomId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoomWithBody(ctx context.Context, roomId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoomRequestWithBody(c.Server, roomId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoom(ctx context.Context, roomId string, body UpdateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoomRequest(c.Server, roomId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScenes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScenesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSceneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSceneRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScene(ctx context.Context, body CreateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSceneRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScene(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSceneRequest(c.Server, sceneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScene(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSceneRequest(c.Server, sceneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSceneWithBody(ctx context.Context, sceneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSceneRequestWithBody(c.Server, sceneId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScene(ctx context.Context, sceneId string, body UpdateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSceneRequest(c.Server, sceneId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZonesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateZoneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateZoneRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateZone(ctx context.Context, body CreateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateZoneRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateZoneWithBody(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateZoneRequestWithBody(c.Server, zoneId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateZone(ctx context.Context, zoneId string, body UpdateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateZoneRequest(c.Server, zoneId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAuthenticateRequest calls the generic Authenticate builder with application/json body
func NewAuthenticateRequest(server string, body AuthenticateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateRequestWithBody generates requests for Authenticate with any type of body
func NewAuthenticateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBridgesRequest generates requests for GetBridges
func NewGetBridgesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/bridge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBridgeRequest generates requests for GetBridge
func NewGetBridgeRequest(server string, bridgeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bridgeId", runtime.ParamLocationPath, bridgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/bridge/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBridgeRequest calls the generic UpdateBridge builder with application/json body
func NewUpdateBridgeRequest(server string, bridgeId string, body UpdateBridgeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBridgeRequestWithBody(server, bridgeId, "application/json", bodyReader)
}

// NewUpdateBridgeRequestWithBody generates requests for UpdateBridge with any type of body
func NewUpdateBridgeRequestWithBody(server string, bridgeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bridgeId", runtime.ParamLocationPath, bridgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/bridge/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBridgeHomesRequest generates requests for GetBridgeHomes
func NewGetBridgeHomesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/bridge_home")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBridgeHomeRequest generates requests for GetBridgeHome
func NewGetBridgeHomeRequest(server string, bridgeHomeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bridgeHomeId", runtime.ParamLocationPath, bridgeHomeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/bridge_home/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLightsRequest generates requests for GetLights
func NewGetLightsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/light")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLightRequest generates requests for GetLight
func NewGetLightRequest(server string, lightId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lightId", runtime.ParamLocationPath, lightId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/light/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLightRequest calls the generic UpdateLight builder with application/json body
func NewUpdateLightRequest(server string, lightId string, body UpdateLightJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLightRequestWithBody(server, lightId, "application/json", bodyReader)
}

// NewUpdateLightRequestWithBody generates requests for UpdateLight with any type of body
func NewUpdateLightRequestWithBody(server string, lightId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lightId", runtime.ParamLocationPath, lightId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/light/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoomsRequest generates requests for GetRooms
func NewGetRoomsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/room")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoomRequest calls the generic CreateRoom builder with application/json body
func NewCreateRoomRequest(server string, body CreateRoomJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoomRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRoomRequestWithBody generates requests for CreateRoom with any type of body
func NewCreateRoomRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/room")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoomRequest generates requests for DeleteRoom
func NewDeleteRoomRequest(server string, roomId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roomId", runtime.ParamLocationPath, roomId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/room/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoomRequest generates requests for GetRoom
func NewGetRoomRequest(server string, roomId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roomId", runtime.ParamLocationPath, roomId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/room/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoomRequest calls the generic UpdateRoom builder with application/json body
func NewUpdateRoomRequest(server string, roomId string, body UpdateRoomJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoomRequestWithBody(server, roomId, "application/json", bodyReader)
}

// NewUpdateRoomRequestWithBody generates requests for UpdateRoom with any type of body
func NewUpdateRoomRequestWithBody(server string, roomId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roomId", runtime.ParamLocationPath, roomId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/room/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetScenesRequest generates requests for GetScenes
func NewGetScenesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/scene")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSceneRequest calls the generic CreateScene builder with application/json body
func NewCreateSceneRequest(server string, body CreateSceneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSceneRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSceneRequestWithBody generates requests for CreateScene with any type of body
func NewCreateSceneRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/scene")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSceneRequest generates requests for DeleteScene
func NewDeleteSceneRequest(server string, sceneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sceneId", runtime.ParamLocationPath, sceneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/scene/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSceneRequest generates requests for GetScene
func NewGetSceneRequest(server string, sceneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sceneId", runtime.ParamLocationPath, sceneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/scene/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSceneRequest calls the generic UpdateScene builder with application/json body
func NewUpdateSceneRequest(server string, sceneId string, body UpdateSceneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSceneRequestWithBody(server, sceneId, "application/json", bodyReader)
}

// NewUpdateSceneRequestWithBody generates requests for UpdateScene with any type of body
func NewUpdateSceneRequestWithBody(server string, sceneId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sceneId", runtime.ParamLocationPath, sceneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/scene/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetZonesRequest generates requests for GetZones
func NewGetZonesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/zone")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateZoneRequest calls the generic CreateZone builder with application/json body
func NewCreateZoneRequest(server string, body CreateZoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateZoneRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateZoneRequestWithBody generates requests for CreateZone with any type of body
func NewCreateZoneRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/zone")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteZoneRequest generates requests for DeleteZone
func NewDeleteZoneRequest(server string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/zone/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetZoneRequest generates requests for GetZone
func NewGetZoneRequest(server string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/zone/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateZoneRequest calls the generic UpdateZone builder with application/json body
func NewUpdateZoneRequest(server string, zoneId string, body UpdateZoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateZoneRequestWithBody(server, zoneId, "application/json", bodyReader)
}

// NewUpdateZoneRequestWithBody generates requests for UpdateZone with any type of body
func NewUpdateZoneRequestWithBody(server string, zoneId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clip/v2/resource/zone/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AuthenticateWithBodyWithResponse request with any body
	AuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error)

	AuthenticateWithResponse(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error)

	// GetResourcesWithResponse request
	GetResourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// GetBridgesWithResponse request
	GetBridgesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBridgesResponse, error)

	// GetBridgeWithResponse request
	GetBridgeWithResponse(ctx context.Context, bridgeId string, reqEditors ...RequestEditorFn) (*GetBridgeResponse, error)

	// UpdateBridgeWithBodyWithResponse request with any body
	UpdateBridgeWithBodyWithResponse(ctx context.Context, bridgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBridgeResponse, error)

	UpdateBridgeWithResponse(ctx context.Context, bridgeId string, body UpdateBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBridgeResponse, error)

	// GetBridgeHomesWithResponse request
	GetBridgeHomesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBridgeHomesResponse, error)

	// GetBridgeHomeWithResponse request
	GetBridgeHomeWithResponse(ctx context.Context, bridgeHomeId string, reqEditors ...RequestEditorFn) (*GetBridgeHomeResponse, error)

	// GetLightsWithResponse request
	GetLightsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLightsResponse, error)

	// GetLightWithResponse request
	GetLightWithResponse(ctx context.Context, lightId string, reqEditors ...RequestEditorFn) (*GetLightResponse, error)

	// UpdateLightWithBodyWithResponse request with any body
	UpdateLightWithBodyWithResponse(ctx context.Context, lightId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLightResponse, error)

	UpdateLightWithResponse(ctx context.Context, lightId string, body UpdateLightJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLightResponse, error)

	// GetRoomsWithResponse request
	GetRoomsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRoomsResponse, error)

	// CreateRoomWithBodyWithResponse request with any body
	CreateRoomWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoomResponse, error)

	CreateRoomWithResponse(ctx context.Context, body CreateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoomResponse, error)

	// DeleteRoomWithResponse request
	DeleteRoomWithResponse(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*DeleteRoomResponse, error)

	// GetRoomWithResponse request
	GetRoomWithResponse(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*GetRoomResponse, error)

	// UpdateRoomWithBodyWithResponse request with any body
	UpdateRoomWithBodyWithResponse(ctx context.Context, roomId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoomResponse, error)

	UpdateRoomWithResponse(ctx context.Context, roomId string, body UpdateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoomResponse, error)

	// GetScenesWithResponse request
	GetScenesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetScenesResponse, error)

	// CreateSceneWithBodyWithResponse request with any body
	CreateSceneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSceneResponse, error)

	CreateSceneWithResponse(ctx context.Context, body CreateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSceneResponse, error)

	// DeleteSceneWithResponse request
	DeleteSceneWithResponse(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*DeleteSceneResponse, error)

	// GetSceneWithResponse request
	GetSceneWithResponse(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*GetSceneResponse, error)

	// UpdateSceneWithBodyWithResponse request with any body
	UpdateSceneWithBodyWithResponse(ctx context.Context, sceneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSceneResponse, error)

	UpdateSceneWithResponse(ctx context.Context, sceneId string, body UpdateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSceneResponse, error)

	// GetZonesWithResponse request
	GetZonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetZonesResponse, error)

	// CreateZoneWithBodyWithResponse request with any body
	CreateZoneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateZoneResponse, error)

	CreateZoneWithResponse(ctx context.Context, body CreateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateZoneResponse, error)

	// DeleteZoneWithResponse request
	DeleteZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*DeleteZoneResponse, error)

	// GetZoneWithResponse request
	GetZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*GetZoneResponse, error)

	// UpdateZoneWithBodyWithResponse request with any body
	UpdateZoneWithBodyWithResponse(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateZoneResponse, error)

	UpdateZoneWithResponse(ctx context.Context, zoneId string, body UpdateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateZoneResponse, error)
}

type AuthenticateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r AuthenticateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceGet `json:"data,omitempty"`
		Errors *[]Error       `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]BridgeGet `json:"data,omitempty"`
		Errors *[]Error     `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetBridgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]BridgeGet `json:"data,omitempty"`
		Errors *[]Error     `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBridgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r UpdateBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeHomesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]BridgeHomeGet `json:"data,omitempty"`
		Errors *[]Error         `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetBridgeHomesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeHomesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeHomeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]BridgeHomeGet `json:"data,omitempty"`
		Errors *[]Error         `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetBridgeHomeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeHomeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]LightGet `json:"data,omitempty"`
		Errors *[]Error    `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetLightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]LightGet `json:"data,omitempty"`
		Errors *[]Error    `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetLightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r UpdateLightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoomsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]RoomGet `json:"data,omitempty"`
		Errors *[]Error   `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetRoomsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoomsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r CreateRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r DeleteRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]RoomGet `json:"data,omitempty"`
		Errors *[]Error   `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r UpdateRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScenesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]SceneGet `json:"data,omitempty"`
		Errors *[]Error    `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetScenesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScenesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSceneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r CreateSceneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSceneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSceneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r DeleteSceneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSceneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSceneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]SceneGet `json:"data,omitempty"`
		Errors *[]Error    `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetSceneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSceneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSceneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r UpdateSceneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSceneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]RoomGet `json:"data,omitempty"`
		Errors *[]Error   `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r CreateZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r DeleteZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]RoomGet `json:"data,omitempty"`
		Errors *[]Error   `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r GetZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ResourceIdentifier `json:"data,omitempty"`
		Errors *[]Error              `json:"errors,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON406 *NotAcceptable
	JSON409 *Conflict
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
	JSON503 *ServiceUnavailable
	JSON507 *InsufficientStorage
}

// Status returns HTTPResponse.Status
func (r UpdateZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AuthenticateWithBodyWithResponse request with arbitrary body returning *AuthenticateResponse
func (c *ClientWithResponses) AuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error) {
	rsp, err := c.AuthenticateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateWithResponse(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error) {
	rsp, err := c.Authenticate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateResponse(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// GetBridgesWithResponse request returning *GetBridgesResponse
func (c *ClientWithResponses) GetBridgesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBridgesResponse, error) {
	rsp, err := c.GetBridges(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgesResponse(rsp)
}

// GetBridgeWithResponse request returning *GetBridgeResponse
func (c *ClientWithResponses) GetBridgeWithResponse(ctx context.Context, bridgeId string, reqEditors ...RequestEditorFn) (*GetBridgeResponse, error) {
	rsp, err := c.GetBridge(ctx, bridgeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeResponse(rsp)
}

// UpdateBridgeWithBodyWithResponse request with arbitrary body returning *UpdateBridgeResponse
func (c *ClientWithResponses) UpdateBridgeWithBodyWithResponse(ctx context.Context, bridgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBridgeResponse, error) {
	rsp, err := c.UpdateBridgeWithBody(ctx, bridgeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBridgeResponse(rsp)
}

func (c *ClientWithResponses) UpdateBridgeWithResponse(ctx context.Context, bridgeId string, body UpdateBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBridgeResponse, error) {
	rsp, err := c.UpdateBridge(ctx, bridgeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBridgeResponse(rsp)
}

// GetBridgeHomesWithResponse request returning *GetBridgeHomesResponse
func (c *ClientWithResponses) GetBridgeHomesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBridgeHomesResponse, error) {
	rsp, err := c.GetBridgeHomes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeHomesResponse(rsp)
}

// GetBridgeHomeWithResponse request returning *GetBridgeHomeResponse
func (c *ClientWithResponses) GetBridgeHomeWithResponse(ctx context.Context, bridgeHomeId string, reqEditors ...RequestEditorFn) (*GetBridgeHomeResponse, error) {
	rsp, err := c.GetBridgeHome(ctx, bridgeHomeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeHomeResponse(rsp)
}

// GetLightsWithResponse request returning *GetLightsResponse
func (c *ClientWithResponses) GetLightsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLightsResponse, error) {
	rsp, err := c.GetLights(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLightsResponse(rsp)
}

// GetLightWithResponse request returning *GetLightResponse
func (c *ClientWithResponses) GetLightWithResponse(ctx context.Context, lightId string, reqEditors ...RequestEditorFn) (*GetLightResponse, error) {
	rsp, err := c.GetLight(ctx, lightId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLightResponse(rsp)
}

// UpdateLightWithBodyWithResponse request with arbitrary body returning *UpdateLightResponse
func (c *ClientWithResponses) UpdateLightWithBodyWithResponse(ctx context.Context, lightId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLightResponse, error) {
	rsp, err := c.UpdateLightWithBody(ctx, lightId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLightResponse(rsp)
}

func (c *ClientWithResponses) UpdateLightWithResponse(ctx context.Context, lightId string, body UpdateLightJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLightResponse, error) {
	rsp, err := c.UpdateLight(ctx, lightId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLightResponse(rsp)
}

// GetRoomsWithResponse request returning *GetRoomsResponse
func (c *ClientWithResponses) GetRoomsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRoomsResponse, error) {
	rsp, err := c.GetRooms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoomsResponse(rsp)
}

// CreateRoomWithBodyWithResponse request with arbitrary body returning *CreateRoomResponse
func (c *ClientWithResponses) CreateRoomWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoomResponse, error) {
	rsp, err := c.CreateRoomWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoomResponse(rsp)
}

func (c *ClientWithResponses) CreateRoomWithResponse(ctx context.Context, body CreateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoomResponse, error) {
	rsp, err := c.CreateRoom(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoomResponse(rsp)
}

// DeleteRoomWithResponse request returning *DeleteRoomResponse
func (c *ClientWithResponses) DeleteRoomWithResponse(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*DeleteRoomResponse, error) {
	rsp, err := c.DeleteRoom(ctx, roomId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoomResponse(rsp)
}

// GetRoomWithResponse request returning *GetRoomResponse
func (c *ClientWithResponses) GetRoomWithResponse(ctx context.Context, roomId string, reqEditors ...RequestEditorFn) (*GetRoomResponse, error) {
	rsp, err := c.GetRoom(ctx, roomId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoomResponse(rsp)
}

// UpdateRoomWithBodyWithResponse request with arbitrary body returning *UpdateRoomResponse
func (c *ClientWithResponses) UpdateRoomWithBodyWithResponse(ctx context.Context, roomId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoomResponse, error) {
	rsp, err := c.UpdateRoomWithBody(ctx, roomId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoomResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoomWithResponse(ctx context.Context, roomId string, body UpdateRoomJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoomResponse, error) {
	rsp, err := c.UpdateRoom(ctx, roomId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoomResponse(rsp)
}

// GetScenesWithResponse request returning *GetScenesResponse
func (c *ClientWithResponses) GetScenesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetScenesResponse, error) {
	rsp, err := c.GetScenes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScenesResponse(rsp)
}

// CreateSceneWithBodyWithResponse request with arbitrary body returning *CreateSceneResponse
func (c *ClientWithResponses) CreateSceneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSceneResponse, error) {
	rsp, err := c.CreateSceneWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSceneResponse(rsp)
}

func (c *ClientWithResponses) CreateSceneWithResponse(ctx context.Context, body CreateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSceneResponse, error) {
	rsp, err := c.CreateScene(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSceneResponse(rsp)
}

// DeleteSceneWithResponse request returning *DeleteSceneResponse
func (c *ClientWithResponses) DeleteSceneWithResponse(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*DeleteSceneResponse, error) {
	rsp, err := c.DeleteScene(ctx, sceneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSceneResponse(rsp)
}

// GetSceneWithResponse request returning *GetSceneResponse
func (c *ClientWithResponses) GetSceneWithResponse(ctx context.Context, sceneId string, reqEditors ...RequestEditorFn) (*GetSceneResponse, error) {
	rsp, err := c.GetScene(ctx, sceneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSceneResponse(rsp)
}

// UpdateSceneWithBodyWithResponse request with arbitrary body returning *UpdateSceneResponse
func (c *ClientWithResponses) UpdateSceneWithBodyWithResponse(ctx context.Context, sceneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSceneResponse, error) {
	rsp, err := c.UpdateSceneWithBody(ctx, sceneId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSceneResponse(rsp)
}

func (c *ClientWithResponses) UpdateSceneWithResponse(ctx context.Context, sceneId string, body UpdateSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSceneResponse, error) {
	rsp, err := c.UpdateScene(ctx, sceneId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSceneResponse(rsp)
}

// GetZonesWithResponse request returning *GetZonesResponse
func (c *ClientWithResponses) GetZonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetZonesResponse, error) {
	rsp, err := c.GetZones(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZonesResponse(rsp)
}

// CreateZoneWithBodyWithResponse request with arbitrary body returning *CreateZoneResponse
func (c *ClientWithResponses) CreateZoneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateZoneResponse, error) {
	rsp, err := c.CreateZoneWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateZoneResponse(rsp)
}

func (c *ClientWithResponses) CreateZoneWithResponse(ctx context.Context, body CreateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateZoneResponse, error) {
	rsp, err := c.CreateZone(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateZoneResponse(rsp)
}

// DeleteZoneWithResponse request returning *DeleteZoneResponse
func (c *ClientWithResponses) DeleteZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*DeleteZoneResponse, error) {
	rsp, err := c.DeleteZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteZoneResponse(rsp)
}

// GetZoneWithResponse request returning *GetZoneResponse
func (c *ClientWithResponses) GetZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*GetZoneResponse, error) {
	rsp, err := c.GetZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZoneResponse(rsp)
}

// UpdateZoneWithBodyWithResponse request with arbitrary body returning *UpdateZoneResponse
func (c *ClientWithResponses) UpdateZoneWithBodyWithResponse(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateZoneResponse, error) {
	rsp, err := c.UpdateZoneWithBody(ctx, zoneId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateZoneResponse(rsp)
}

func (c *ClientWithResponses) UpdateZoneWithResponse(ctx context.Context, zoneId string, body UpdateZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateZoneResponse, error) {
	rsp, err := c.UpdateZone(ctx, zoneId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateZoneResponse(rsp)
}

// ParseAuthenticateResponse parses an HTTP response from a AuthenticateWithResponse call
func ParseAuthenticateResponse(rsp *http.Response) (*AuthenticateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceGet `json:"data,omitempty"`
			Errors *[]Error       `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetBridgesResponse parses an HTTP response from a GetBridgesWithResponse call
func ParseGetBridgesResponse(rsp *http.Response) (*GetBridgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]BridgeGet `json:"data,omitempty"`
			Errors *[]Error     `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetBridgeResponse parses an HTTP response from a GetBridgeWithResponse call
func ParseGetBridgeResponse(rsp *http.Response) (*GetBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]BridgeGet `json:"data,omitempty"`
			Errors *[]Error     `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseUpdateBridgeResponse parses an HTTP response from a UpdateBridgeWithResponse call
func ParseUpdateBridgeResponse(rsp *http.Response) (*UpdateBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetBridgeHomesResponse parses an HTTP response from a GetBridgeHomesWithResponse call
func ParseGetBridgeHomesResponse(rsp *http.Response) (*GetBridgeHomesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeHomesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]BridgeHomeGet `json:"data,omitempty"`
			Errors *[]Error         `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetBridgeHomeResponse parses an HTTP response from a GetBridgeHomeWithResponse call
func ParseGetBridgeHomeResponse(rsp *http.Response) (*GetBridgeHomeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeHomeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]BridgeHomeGet `json:"data,omitempty"`
			Errors *[]Error         `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetLightsResponse parses an HTTP response from a GetLightsWithResponse call
func ParseGetLightsResponse(rsp *http.Response) (*GetLightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]LightGet `json:"data,omitempty"`
			Errors *[]Error    `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetLightResponse parses an HTTP response from a GetLightWithResponse call
func ParseGetLightResponse(rsp *http.Response) (*GetLightResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]LightGet `json:"data,omitempty"`
			Errors *[]Error    `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseUpdateLightResponse parses an HTTP response from a UpdateLightWithResponse call
func ParseUpdateLightResponse(rsp *http.Response) (*UpdateLightResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetRoomsResponse parses an HTTP response from a GetRoomsWithResponse call
func ParseGetRoomsResponse(rsp *http.Response) (*GetRoomsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoomsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]RoomGet `json:"data,omitempty"`
			Errors *[]Error   `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseCreateRoomResponse parses an HTTP response from a CreateRoomWithResponse call
func ParseCreateRoomResponse(rsp *http.Response) (*CreateRoomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseDeleteRoomResponse parses an HTTP response from a DeleteRoomWithResponse call
func ParseDeleteRoomResponse(rsp *http.Response) (*DeleteRoomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetRoomResponse parses an HTTP response from a GetRoomWithResponse call
func ParseGetRoomResponse(rsp *http.Response) (*GetRoomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]RoomGet `json:"data,omitempty"`
			Errors *[]Error   `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseUpdateRoomResponse parses an HTTP response from a UpdateRoomWithResponse call
func ParseUpdateRoomResponse(rsp *http.Response) (*UpdateRoomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetScenesResponse parses an HTTP response from a GetScenesWithResponse call
func ParseGetScenesResponse(rsp *http.Response) (*GetScenesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScenesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]SceneGet `json:"data,omitempty"`
			Errors *[]Error    `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseCreateSceneResponse parses an HTTP response from a CreateSceneWithResponse call
func ParseCreateSceneResponse(rsp *http.Response) (*CreateSceneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSceneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseDeleteSceneResponse parses an HTTP response from a DeleteSceneWithResponse call
func ParseDeleteSceneResponse(rsp *http.Response) (*DeleteSceneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSceneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetSceneResponse parses an HTTP response from a GetSceneWithResponse call
func ParseGetSceneResponse(rsp *http.Response) (*GetSceneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSceneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]SceneGet `json:"data,omitempty"`
			Errors *[]Error    `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseUpdateSceneResponse parses an HTTP response from a UpdateSceneWithResponse call
func ParseUpdateSceneResponse(rsp *http.Response) (*UpdateSceneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSceneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetZonesResponse parses an HTTP response from a GetZonesWithResponse call
func ParseGetZonesResponse(rsp *http.Response) (*GetZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]RoomGet `json:"data,omitempty"`
			Errors *[]Error   `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseCreateZoneResponse parses an HTTP response from a CreateZoneWithResponse call
func ParseCreateZoneResponse(rsp *http.Response) (*CreateZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseDeleteZoneResponse parses an HTTP response from a DeleteZoneWithResponse call
func ParseDeleteZoneResponse(rsp *http.Response) (*DeleteZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseGetZoneResponse parses an HTTP response from a GetZoneWithResponse call
func ParseGetZoneResponse(rsp *http.Response) (*GetZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]RoomGet `json:"data,omitempty"`
			Errors *[]Error   `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}

// ParseUpdateZoneResponse parses an HTTP response from a UpdateZoneWithResponse call
func ParseUpdateZoneResponse(rsp *http.Response) (*UpdateZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ResourceIdentifier `json:"data,omitempty"`
			Errors *[]Error              `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 507:
		var dest InsufficientStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON507 = &dest

	}

	return response, nil
}
